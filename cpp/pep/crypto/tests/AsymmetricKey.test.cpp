#include <gtest/gtest.h>

#include <pep/crypto/AsymmetricKey.hpp>
#include <pep/utils/Sha.hpp>

namespace {

const std::string inputPublicKeyPEM = "-----BEGIN PUBLIC KEY-----\n\
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwaMF5e3GIDgyqUN/O4Y3\n\
FHXrmXBIJ+jLfas0Nkd8ckPdYQbRB5EhlX6DzraEvGzKpoox+Z1hCO6+QIBclek8\n\
3oNFbK63iB+iBz8xm+uMm4OkG+CW/BAnCmoM1gciM74OZgHcCSHM+zbHTQUSidqj\n\
tDbrpAHATN4nOwlE413ACkSq5nf7v4oJUKRLtLhL7xei5EKbP8Tm/4sK7wjitnoJ\n\
50TqY9CqBMfDMV0IkiJkaMF+LCoj5E0zkcNwwR39D924ra92w90rEityodsF819U\n\
IvRR2Whx6UelmLdPoxt34DJrUM0SJmgvpi1P2seSF2CS0zK8VnCJM11G1Tosy7R5\n\
sQIDAQAB\n\
-----END PUBLIC KEY-----\n";

// Created as follows:
// 1. Store inputPublicKeyPEM in file publickey.pem
// 2. openssl rsa -pubin -in publickey.pem -outform DER -out - | xxd --include
const std::vector<unsigned char> inputPublicKeyDerVector= {
  0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
  0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
  0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc1, 0xa3, 0x05,
  0xe5, 0xed, 0xc6, 0x20, 0x38, 0x32, 0xa9, 0x43, 0x7f, 0x3b, 0x86, 0x37,
  0x14, 0x75, 0xeb, 0x99, 0x70, 0x48, 0x27, 0xe8, 0xcb, 0x7d, 0xab, 0x34,
  0x36, 0x47, 0x7c, 0x72, 0x43, 0xdd, 0x61, 0x06, 0xd1, 0x07, 0x91, 0x21,
  0x95, 0x7e, 0x83, 0xce, 0xb6, 0x84, 0xbc, 0x6c, 0xca, 0xa6, 0x8a, 0x31,
  0xf9, 0x9d, 0x61, 0x08, 0xee, 0xbe, 0x40, 0x80, 0x5c, 0x95, 0xe9, 0x3c,
  0xde, 0x83, 0x45, 0x6c, 0xae, 0xb7, 0x88, 0x1f, 0xa2, 0x07, 0x3f, 0x31,
  0x9b, 0xeb, 0x8c, 0x9b, 0x83, 0xa4, 0x1b, 0xe0, 0x96, 0xfc, 0x10, 0x27,
  0x0a, 0x6a, 0x0c, 0xd6, 0x07, 0x22, 0x33, 0xbe, 0x0e, 0x66, 0x01, 0xdc,
  0x09, 0x21, 0xcc, 0xfb, 0x36, 0xc7, 0x4d, 0x05, 0x12, 0x89, 0xda, 0xa3,
  0xb4, 0x36, 0xeb, 0xa4, 0x01, 0xc0, 0x4c, 0xde, 0x27, 0x3b, 0x09, 0x44,
  0xe3, 0x5d, 0xc0, 0x0a, 0x44, 0xaa, 0xe6, 0x77, 0xfb, 0xbf, 0x8a, 0x09,
  0x50, 0xa4, 0x4b, 0xb4, 0xb8, 0x4b, 0xef, 0x17, 0xa2, 0xe4, 0x42, 0x9b,
  0x3f, 0xc4, 0xe6, 0xff, 0x8b, 0x0a, 0xef, 0x08, 0xe2, 0xb6, 0x7a, 0x09,
  0xe7, 0x44, 0xea, 0x63, 0xd0, 0xaa, 0x04, 0xc7, 0xc3, 0x31, 0x5d, 0x08,
  0x92, 0x22, 0x64, 0x68, 0xc1, 0x7e, 0x2c, 0x2a, 0x23, 0xe4, 0x4d, 0x33,
  0x91, 0xc3, 0x70, 0xc1, 0x1d, 0xfd, 0x0f, 0xdd, 0xb8, 0xad, 0xaf, 0x76,
  0xc3, 0xdd, 0x2b, 0x12, 0x2b, 0x72, 0xa1, 0xdb, 0x05, 0xf3, 0x5f, 0x54,
  0x22, 0xf4, 0x51, 0xd9, 0x68, 0x71, 0xe9, 0x47, 0xa5, 0x98, 0xb7, 0x4f,
  0xa3, 0x1b, 0x77, 0xe0, 0x32, 0x6b, 0x50, 0xcd, 0x12, 0x26, 0x68, 0x2f,
  0xa6, 0x2d, 0x4f, 0xda, 0xc7, 0x92, 0x17, 0x60, 0x92, 0xd3, 0x32, 0xbc,
  0x56, 0x70, 0x89, 0x33, 0x5d, 0x46, 0xd5, 0x3a, 0x2c, 0xcb, 0xb4, 0x79,
  0xb1, 0x02, 0x03, 0x01, 0x00, 0x01
};
const std::string inputPublicKeyDER(reinterpret_cast<char const*>(inputPublicKeyDerVector.data()), inputPublicKeyDerVector.size());

const std::string inputPrivateKeyPEM = "-----BEGIN PRIVATE KEY-----\n\
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDBowXl7cYgODKp\n\
Q387hjcUdeuZcEgn6Mt9qzQ2R3xyQ91hBtEHkSGVfoPOtoS8bMqmijH5nWEI7r5A\n\
gFyV6Tzeg0VsrreIH6IHPzGb64ybg6Qb4Jb8ECcKagzWByIzvg5mAdwJIcz7NsdN\n\
BRKJ2qO0NuukAcBM3ic7CUTjXcAKRKrmd/u/iglQpEu0uEvvF6LkQps/xOb/iwrv\n\
COK2egnnROpj0KoEx8MxXQiSImRowX4sKiPkTTORw3DBHf0P3bitr3bD3SsSK3Kh\n\
2wXzX1Qi9FHZaHHpR6WYt0+jG3fgMmtQzRImaC+mLU/ax5IXYJLTMrxWcIkzXUbV\n\
OizLtHmxAgMBAAECggEAOX/0b2ulCspFWPf/Hyji0EOX+49ZDejWDHI7ZebicHfw\n\
lDBW//070M2pzEdssRtJLh0Za/ss5l8mxbaYR7fj6Fto0TYsr9Jc5fQBAkD3FvMH\n\
V3Pgweb2AOSu/RtPL7g/RFFHCrsryGli018vOxpexFQOszwF442Qbrp4519eeG2Y\n\
1eY8/TjwHmJnch3SRgIV+6WBEjNZEe4rbrXeGvPdh0zJJe/hF5mfJl4IMoAJ5xKy\n\
l36Blq67EhkjhtQhr9u9lra7onw3XYp8BPU+Xe1BkJRd7q3rYGGV+0SswPEmaMb+\n\
iq5kKhKVQbjERewdexMOSlkKG70OdoXFghq8QeHhMQKBgQD0kqUQrMdJLeodEM0D\n\
Y/OxxMdS3VuAdbzCuF7gEKzzQBH4a/LOiBGm3oke46bXCmmnyDezLp+s7OCoBAl0\n\
WrWJHcrCsWZBOgAA66PDbMDXzjv+588gZOjbkF7MO+PK+pwjH2n7Z1fCH4Qg4Jd4\n\
4s2Bn9fYC/UIC1SxlYDtSzzZFQKBgQDKryDflVVaZPdujR5o60TUCrejrj3ylzu/\n\
yiYIlSyY2rU8GPnnBHGDXO2VP7fwdcNuwbKt44sd8xYyaMOnPUmUR7yT2pYJ++z3\n\
TZ7wgVX/cbNHcjMKlX95L9cSlPu5w00Sq+VcK3Xv2AIRkWF5ptqVXzHX+zKxDrid\n\
xlFBwZtNLQKBgClK7RWgplEDsIhRwtt0r7tu5txlxUIuHr2dlV8tUZYMVjxkNW2L\n\
abeL0QjnFM8v0eDjHAxjrc/reo7Dh7kea5IH9qjifMo8ea2uG0sufGyzREvoZX8p\n\
qmsPuAGxhudJYr1HW4R30UhUO+G1Kb3eRSZCj5XJhwhhqV4GSOtHjbF1AoGAVZe3\n\
bjQGI3JX+1uk5/HS0yjjfD/s8TFkjg20GhPFDZfuyT5S6ng555uqyUhrSSSyL2el\n\
KUHaUf+B9C/B0DJVjETvIhFBI148KAOjhzVXN9SwPQ/A9ktD1c2aKcK4uy36slPd\n\
PBsuZub1mK2oWFNaI5Jb3jW6poLs+9PwJLC6ANECgYEAxQWK3vJdL0XpOGs00Jhl\n\
J5Vdmj2xenh7YV+UGmNgdlzNyI8y5SXkv6oFCyQTcSdTufnmPXuq0Xzzrsh2xeyN\n\
C52JvmmdV/McGyvofcrO6k8FLjcnW/LDl/H0S3AKfv2BeuMNs6WoSf1XNUqGeoEE\n\
eyHRyJZfq/3PsEhrYlf63vA=\n\
-----END PRIVATE KEY-----\n";

// Created as follows:
// 1. Store inputPrivateKeyPEM in file privatekey.pem
// 2. openssl rsa -in privatekey.pem -outform DER -out - | xxd --include
const std::vector<unsigned char> inputPrivateKeyDerVector= {
  0x30, 0x82, 0x04, 0xbd, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a,
  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82,
  0x04, 0xa7, 0x30, 0x82, 0x04, 0xa3, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01,
  0x01, 0x00, 0xc1, 0xa3, 0x05, 0xe5, 0xed, 0xc6, 0x20, 0x38, 0x32, 0xa9,
  0x43, 0x7f, 0x3b, 0x86, 0x37, 0x14, 0x75, 0xeb, 0x99, 0x70, 0x48, 0x27,
  0xe8, 0xcb, 0x7d, 0xab, 0x34, 0x36, 0x47, 0x7c, 0x72, 0x43, 0xdd, 0x61,
  0x06, 0xd1, 0x07, 0x91, 0x21, 0x95, 0x7e, 0x83, 0xce, 0xb6, 0x84, 0xbc,
  0x6c, 0xca, 0xa6, 0x8a, 0x31, 0xf9, 0x9d, 0x61, 0x08, 0xee, 0xbe, 0x40,
  0x80, 0x5c, 0x95, 0xe9, 0x3c, 0xde, 0x83, 0x45, 0x6c, 0xae, 0xb7, 0x88,
  0x1f, 0xa2, 0x07, 0x3f, 0x31, 0x9b, 0xeb, 0x8c, 0x9b, 0x83, 0xa4, 0x1b,
  0xe0, 0x96, 0xfc, 0x10, 0x27, 0x0a, 0x6a, 0x0c, 0xd6, 0x07, 0x22, 0x33,
  0xbe, 0x0e, 0x66, 0x01, 0xdc, 0x09, 0x21, 0xcc, 0xfb, 0x36, 0xc7, 0x4d,
  0x05, 0x12, 0x89, 0xda, 0xa3, 0xb4, 0x36, 0xeb, 0xa4, 0x01, 0xc0, 0x4c,
  0xde, 0x27, 0x3b, 0x09, 0x44, 0xe3, 0x5d, 0xc0, 0x0a, 0x44, 0xaa, 0xe6,
  0x77, 0xfb, 0xbf, 0x8a, 0x09, 0x50, 0xa4, 0x4b, 0xb4, 0xb8, 0x4b, 0xef,
  0x17, 0xa2, 0xe4, 0x42, 0x9b, 0x3f, 0xc4, 0xe6, 0xff, 0x8b, 0x0a, 0xef,
  0x08, 0xe2, 0xb6, 0x7a, 0x09, 0xe7, 0x44, 0xea, 0x63, 0xd0, 0xaa, 0x04,
  0xc7, 0xc3, 0x31, 0x5d, 0x08, 0x92, 0x22, 0x64, 0x68, 0xc1, 0x7e, 0x2c,
  0x2a, 0x23, 0xe4, 0x4d, 0x33, 0x91, 0xc3, 0x70, 0xc1, 0x1d, 0xfd, 0x0f,
  0xdd, 0xb8, 0xad, 0xaf, 0x76, 0xc3, 0xdd, 0x2b, 0x12, 0x2b, 0x72, 0xa1,
  0xdb, 0x05, 0xf3, 0x5f, 0x54, 0x22, 0xf4, 0x51, 0xd9, 0x68, 0x71, 0xe9,
  0x47, 0xa5, 0x98, 0xb7, 0x4f, 0xa3, 0x1b, 0x77, 0xe0, 0x32, 0x6b, 0x50,
  0xcd, 0x12, 0x26, 0x68, 0x2f, 0xa6, 0x2d, 0x4f, 0xda, 0xc7, 0x92, 0x17,
  0x60, 0x92, 0xd3, 0x32, 0xbc, 0x56, 0x70, 0x89, 0x33, 0x5d, 0x46, 0xd5,
  0x3a, 0x2c, 0xcb, 0xb4, 0x79, 0xb1, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02,
  0x82, 0x01, 0x00, 0x39, 0x7f, 0xf4, 0x6f, 0x6b, 0xa5, 0x0a, 0xca, 0x45,
  0x58, 0xf7, 0xff, 0x1f, 0x28, 0xe2, 0xd0, 0x43, 0x97, 0xfb, 0x8f, 0x59,
  0x0d, 0xe8, 0xd6, 0x0c, 0x72, 0x3b, 0x65, 0xe6, 0xe2, 0x70, 0x77, 0xf0,
  0x94, 0x30, 0x56, 0xff, 0xfd, 0x3b, 0xd0, 0xcd, 0xa9, 0xcc, 0x47, 0x6c,
  0xb1, 0x1b, 0x49, 0x2e, 0x1d, 0x19, 0x6b, 0xfb, 0x2c, 0xe6, 0x5f, 0x26,
  0xc5, 0xb6, 0x98, 0x47, 0xb7, 0xe3, 0xe8, 0x5b, 0x68, 0xd1, 0x36, 0x2c,
  0xaf, 0xd2, 0x5c, 0xe5, 0xf4, 0x01, 0x02, 0x40, 0xf7, 0x16, 0xf3, 0x07,
  0x57, 0x73, 0xe0, 0xc1, 0xe6, 0xf6, 0x00, 0xe4, 0xae, 0xfd, 0x1b, 0x4f,
  0x2f, 0xb8, 0x3f, 0x44, 0x51, 0x47, 0x0a, 0xbb, 0x2b, 0xc8, 0x69, 0x62,
  0xd3, 0x5f, 0x2f, 0x3b, 0x1a, 0x5e, 0xc4, 0x54, 0x0e, 0xb3, 0x3c, 0x05,
  0xe3, 0x8d, 0x90, 0x6e, 0xba, 0x78, 0xe7, 0x5f, 0x5e, 0x78, 0x6d, 0x98,
  0xd5, 0xe6, 0x3c, 0xfd, 0x38, 0xf0, 0x1e, 0x62, 0x67, 0x72, 0x1d, 0xd2,
  0x46, 0x02, 0x15, 0xfb, 0xa5, 0x81, 0x12, 0x33, 0x59, 0x11, 0xee, 0x2b,
  0x6e, 0xb5, 0xde, 0x1a, 0xf3, 0xdd, 0x87, 0x4c, 0xc9, 0x25, 0xef, 0xe1,
  0x17, 0x99, 0x9f, 0x26, 0x5e, 0x08, 0x32, 0x80, 0x09, 0xe7, 0x12, 0xb2,
  0x97, 0x7e, 0x81, 0x96, 0xae, 0xbb, 0x12, 0x19, 0x23, 0x86, 0xd4, 0x21,
  0xaf, 0xdb, 0xbd, 0x96, 0xb6, 0xbb, 0xa2, 0x7c, 0x37, 0x5d, 0x8a, 0x7c,
  0x04, 0xf5, 0x3e, 0x5d, 0xed, 0x41, 0x90, 0x94, 0x5d, 0xee, 0xad, 0xeb,
  0x60, 0x61, 0x95, 0xfb, 0x44, 0xac, 0xc0, 0xf1, 0x26, 0x68, 0xc6, 0xfe,
  0x8a, 0xae, 0x64, 0x2a, 0x12, 0x95, 0x41, 0xb8, 0xc4, 0x45, 0xec, 0x1d,
  0x7b, 0x13, 0x0e, 0x4a, 0x59, 0x0a, 0x1b, 0xbd, 0x0e, 0x76, 0x85, 0xc5,
  0x82, 0x1a, 0xbc, 0x41, 0xe1, 0xe1, 0x31, 0x02, 0x81, 0x81, 0x00, 0xf4,
  0x92, 0xa5, 0x10, 0xac, 0xc7, 0x49, 0x2d, 0xea, 0x1d, 0x10, 0xcd, 0x03,
  0x63, 0xf3, 0xb1, 0xc4, 0xc7, 0x52, 0xdd, 0x5b, 0x80, 0x75, 0xbc, 0xc2,
  0xb8, 0x5e, 0xe0, 0x10, 0xac, 0xf3, 0x40, 0x11, 0xf8, 0x6b, 0xf2, 0xce,
  0x88, 0x11, 0xa6, 0xde, 0x89, 0x1e, 0xe3, 0xa6, 0xd7, 0x0a, 0x69, 0xa7,
  0xc8, 0x37, 0xb3, 0x2e, 0x9f, 0xac, 0xec, 0xe0, 0xa8, 0x04, 0x09, 0x74,
  0x5a, 0xb5, 0x89, 0x1d, 0xca, 0xc2, 0xb1, 0x66, 0x41, 0x3a, 0x00, 0x00,
  0xeb, 0xa3, 0xc3, 0x6c, 0xc0, 0xd7, 0xce, 0x3b, 0xfe, 0xe7, 0xcf, 0x20,
  0x64, 0xe8, 0xdb, 0x90, 0x5e, 0xcc, 0x3b, 0xe3, 0xca, 0xfa, 0x9c, 0x23,
  0x1f, 0x69, 0xfb, 0x67, 0x57, 0xc2, 0x1f, 0x84, 0x20, 0xe0, 0x97, 0x78,
  0xe2, 0xcd, 0x81, 0x9f, 0xd7, 0xd8, 0x0b, 0xf5, 0x08, 0x0b, 0x54, 0xb1,
  0x95, 0x80, 0xed, 0x4b, 0x3c, 0xd9, 0x15, 0x02, 0x81, 0x81, 0x00, 0xca,
  0xaf, 0x20, 0xdf, 0x95, 0x55, 0x5a, 0x64, 0xf7, 0x6e, 0x8d, 0x1e, 0x68,
  0xeb, 0x44, 0xd4, 0x0a, 0xb7, 0xa3, 0xae, 0x3d, 0xf2, 0x97, 0x3b, 0xbf,
  0xca, 0x26, 0x08, 0x95, 0x2c, 0x98, 0xda, 0xb5, 0x3c, 0x18, 0xf9, 0xe7,
  0x04, 0x71, 0x83, 0x5c, 0xed, 0x95, 0x3f, 0xb7, 0xf0, 0x75, 0xc3, 0x6e,
  0xc1, 0xb2, 0xad, 0xe3, 0x8b, 0x1d, 0xf3, 0x16, 0x32, 0x68, 0xc3, 0xa7,
  0x3d, 0x49, 0x94, 0x47, 0xbc, 0x93, 0xda, 0x96, 0x09, 0xfb, 0xec, 0xf7,
  0x4d, 0x9e, 0xf0, 0x81, 0x55, 0xff, 0x71, 0xb3, 0x47, 0x72, 0x33, 0x0a,
  0x95, 0x7f, 0x79, 0x2f, 0xd7, 0x12, 0x94, 0xfb, 0xb9, 0xc3, 0x4d, 0x12,
  0xab, 0xe5, 0x5c, 0x2b, 0x75, 0xef, 0xd8, 0x02, 0x11, 0x91, 0x61, 0x79,
  0xa6, 0xda, 0x95, 0x5f, 0x31, 0xd7, 0xfb, 0x32, 0xb1, 0x0e, 0xb8, 0x9d,
  0xc6, 0x51, 0x41, 0xc1, 0x9b, 0x4d, 0x2d, 0x02, 0x81, 0x80, 0x29, 0x4a,
  0xed, 0x15, 0xa0, 0xa6, 0x51, 0x03, 0xb0, 0x88, 0x51, 0xc2, 0xdb, 0x74,
  0xaf, 0xbb, 0x6e, 0xe6, 0xdc, 0x65, 0xc5, 0x42, 0x2e, 0x1e, 0xbd, 0x9d,
  0x95, 0x5f, 0x2d, 0x51, 0x96, 0x0c, 0x56, 0x3c, 0x64, 0x35, 0x6d, 0x8b,
  0x69, 0xb7, 0x8b, 0xd1, 0x08, 0xe7, 0x14, 0xcf, 0x2f, 0xd1, 0xe0, 0xe3,
  0x1c, 0x0c, 0x63, 0xad, 0xcf, 0xeb, 0x7a, 0x8e, 0xc3, 0x87, 0xb9, 0x1e,
  0x6b, 0x92, 0x07, 0xf6, 0xa8, 0xe2, 0x7c, 0xca, 0x3c, 0x79, 0xad, 0xae,
  0x1b, 0x4b, 0x2e, 0x7c, 0x6c, 0xb3, 0x44, 0x4b, 0xe8, 0x65, 0x7f, 0x29,
  0xaa, 0x6b, 0x0f, 0xb8, 0x01, 0xb1, 0x86, 0xe7, 0x49, 0x62, 0xbd, 0x47,
  0x5b, 0x84, 0x77, 0xd1, 0x48, 0x54, 0x3b, 0xe1, 0xb5, 0x29, 0xbd, 0xde,
  0x45, 0x26, 0x42, 0x8f, 0x95, 0xc9, 0x87, 0x08, 0x61, 0xa9, 0x5e, 0x06,
  0x48, 0xeb, 0x47, 0x8d, 0xb1, 0x75, 0x02, 0x81, 0x80, 0x55, 0x97, 0xb7,
  0x6e, 0x34, 0x06, 0x23, 0x72, 0x57, 0xfb, 0x5b, 0xa4, 0xe7, 0xf1, 0xd2,
  0xd3, 0x28, 0xe3, 0x7c, 0x3f, 0xec, 0xf1, 0x31, 0x64, 0x8e, 0x0d, 0xb4,
  0x1a, 0x13, 0xc5, 0x0d, 0x97, 0xee, 0xc9, 0x3e, 0x52, 0xea, 0x78, 0x39,
  0xe7, 0x9b, 0xaa, 0xc9, 0x48, 0x6b, 0x49, 0x24, 0xb2, 0x2f, 0x67, 0xa5,
  0x29, 0x41, 0xda, 0x51, 0xff, 0x81, 0xf4, 0x2f, 0xc1, 0xd0, 0x32, 0x55,
  0x8c, 0x44, 0xef, 0x22, 0x11, 0x41, 0x23, 0x5e, 0x3c, 0x28, 0x03, 0xa3,
  0x87, 0x35, 0x57, 0x37, 0xd4, 0xb0, 0x3d, 0x0f, 0xc0, 0xf6, 0x4b, 0x43,
  0xd5, 0xcd, 0x9a, 0x29, 0xc2, 0xb8, 0xbb, 0x2d, 0xfa, 0xb2, 0x53, 0xdd,
  0x3c, 0x1b, 0x2e, 0x66, 0xe6, 0xf5, 0x98, 0xad, 0xa8, 0x58, 0x53, 0x5a,
  0x23, 0x92, 0x5b, 0xde, 0x35, 0xba, 0xa6, 0x82, 0xec, 0xfb, 0xd3, 0xf0,
  0x24, 0xb0, 0xba, 0x00, 0xd1, 0x02, 0x81, 0x81, 0x00, 0xc5, 0x05, 0x8a,
  0xde, 0xf2, 0x5d, 0x2f, 0x45, 0xe9, 0x38, 0x6b, 0x34, 0xd0, 0x98, 0x65,
  0x27, 0x95, 0x5d, 0x9a, 0x3d, 0xb1, 0x7a, 0x78, 0x7b, 0x61, 0x5f, 0x94,
  0x1a, 0x63, 0x60, 0x76, 0x5c, 0xcd, 0xc8, 0x8f, 0x32, 0xe5, 0x25, 0xe4,
  0xbf, 0xaa, 0x05, 0x0b, 0x24, 0x13, 0x71, 0x27, 0x53, 0xb9, 0xf9, 0xe6,
  0x3d, 0x7b, 0xaa, 0xd1, 0x7c, 0xf3, 0xae, 0xc8, 0x76, 0xc5, 0xec, 0x8d,
  0x0b, 0x9d, 0x89, 0xbe, 0x69, 0x9d, 0x57, 0xf3, 0x1c, 0x1b, 0x2b, 0xe8,
  0x7d, 0xca, 0xce, 0xea, 0x4f, 0x05, 0x2e, 0x37, 0x27, 0x5b, 0xf2, 0xc3,
  0x97, 0xf1, 0xf4, 0x4b, 0x70, 0x0a, 0x7e, 0xfd, 0x81, 0x7a, 0xe3, 0x0d,
  0xb3, 0xa5, 0xa8, 0x49, 0xfd, 0x57, 0x35, 0x4a, 0x86, 0x7a, 0x81, 0x04,
  0x7b, 0x21, 0xd1, 0xc8, 0x96, 0x5f, 0xab, 0xfd, 0xcf, 0xb0, 0x48, 0x6b,
  0x62, 0x57, 0xfa, 0xde, 0xf0
};
const std::string inputPrivateKeyDER(reinterpret_cast<char const*>(inputPrivateKeyDerVector.data()), inputPrivateKeyDerVector.size());


// Keys in PKCS#1 format, the rest of the keys are in PKCS#8 format
// The difference is that PKCS#1 has the key type in the header, while
// PKCS#8 has the key type in the body under an OID
const std::string inputPublicKeyPEMPKCS1 = "-----BEGIN PUBLIC KEY-----\n\
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtvOGfpbZiKDOR6jl6wnx\n\
Y9QdX0blVNlLS9OWunzv3a2+Oeaw3F+kwxh0R+qPfBOaNO3muW9stWNVw6zwAnNY\n\
zOrGjz9LMcCVxeWir8m4Z+wYbhq/jav4+arHRFFGDmOGbl+a2TSFQe1eEOdmQD2r\n\
0n/shZBLViMWlq72M0VfttViOBwgBgxSSQEDM1LNQ7rpFNzyCLo+Y3HyK6b0EWth\n\
K+4CszlNKTupZxk1G2lfhmYYI5a2VMG479epHPfcOCUfZwco9OlgYW7GOvktqWO4\n\
sj9N4RC/AmDYg2CN2md9qwVo7wJJuLwGzxBZU1o/JQpcIwJx2rXaP3VegYTkuUPq\n\
VQIDAQAB\n\
-----END PUBLIC KEY-----\n";

const std::string inputPrivateKeyPEMPKCS1 = "-----BEGIN RSA PRIVATE KEY-----\n\
MIIEogIBAAKCAQEAtvOGfpbZiKDOR6jl6wnxY9QdX0blVNlLS9OWunzv3a2+Oeaw\n\
3F+kwxh0R+qPfBOaNO3muW9stWNVw6zwAnNYzOrGjz9LMcCVxeWir8m4Z+wYbhq/\n\
jav4+arHRFFGDmOGbl+a2TSFQe1eEOdmQD2r0n/shZBLViMWlq72M0VfttViOBwg\n\
BgxSSQEDM1LNQ7rpFNzyCLo+Y3HyK6b0EWthK+4CszlNKTupZxk1G2lfhmYYI5a2\n\
VMG479epHPfcOCUfZwco9OlgYW7GOvktqWO4sj9N4RC/AmDYg2CN2md9qwVo7wJJ\n\
uLwGzxBZU1o/JQpcIwJx2rXaP3VegYTkuUPqVQIDAQABAoIBABYj1GPfZ4XkR/Je\n\
GyzdcCvvkHpmPvyMq1MK0RPSaMi/7ORe6YpRvMOrYu8NEL4oNSIwpBpOxK4Szl82\n\
v3jccqOhydOuCjCEKNvhFVYGqF1TMgWpEQNZC3FTXHgFCeBV5P/YbAnbFEFNM3QC\n\
PNqLXA7GUl47fxJ2fpZPqBW+UH30kjI9rPWMdsw3SIxMU565sRPji0Je1DsFvmKz\n\
CYCcLMEjvVOx4/sDGs1g17hvC7LQUBVhUrHUjRWsbYzT6jOl9sf/pmdyC3zTfCbY\n\
W8bf3/c9JWQiH4SwR+qwXmG+x9RlGmYU1qX6w44MadUIsWYwTzvYeLmaw2HD6CFE\n\
w/mBhSECgYEA6+IVwGblymB1KyJkfc9iG3/A5kQgx9fDRXq38ZPx1QvK/UuRPvO6\n\
+AMmJg/5lZXa0K5ogJPiqzJi6y6eM1R543SJZEgZJwSbbYYS0NPaxlVVyqlk1dnq\n\
AqmzMQDMppbwRgf8hJ6hEF1Xwcfy5MJRcbfxeqY9r0SjhIio/0uH4W0CgYEAxo3O\n\
XTGNOsX5Nfo+RECP8OBUl8tgBTiQ9xxf8gHb40yh/UG46lGMxWMvrKa0DaoMM89i\n\
sTadbzatWdwZEdcr+pWtTSUh/Me7hpiK/qNis7T2ynqqNhVk5rud5iid/CDd8moQ\n\
sFIQEU5QC8wCFO0kOk1hMPsYTS2FEIRWWkSIA4kCgYBsZBiAsAfZxhcxOf2Zfklj\n\
v4HBjf7ONgxqCekqnkQbFO8zE51row4AV1oZVW/n19OT3wDwTIR1DJM95M8XYTMd\n\
XPihVywPrONLIbfVs/Qs/RuOI+bNCfSpQpev5eEkj+lbFOJpgocagPoJdrrbeZt5\n\
OQBCzs87kbvd8/pMTcXjxQKBgAP5ksgK1ej3TaXm/JghMsB/vTHMwH9aQoyv5LvT\n\
jbNfNV78kdcfCtJoyeuK6s/bN6NR44for/4p+g5yeY4B4L+Df5SryaJl3Ts0kpPG\n\
cZNnbAlhq0ap5vs3hlG1PnRttAPGW88r1WaDStbxnpkMpk0Ef42beUESSDesbo4g\n\
ERkBAoGAVunEU/yV7uJbRrKL5pSD2yYmvLCs19GF6+312U0ZQRJV30CBGLmi2GE8\n\
Z1GvKsSTiKzej8tlWxWCVcbJGuH92LWcZ1SWZIC5HXf8aNAoEcNGZ8pUzurWJy/w\n\
t9jn4n8oS5x/IUZaWdfoEJ6p6FLlx/DvtubHnZzd7AGv1NmDdk0=\n\
-----END RSA PRIVATE KEY-----\n";

const std::string inputPublicKeyPEMSignatureTest = "-----BEGIN RSA PUBLIC KEY-----\n\
MIIBCgKCAQEAzp1LfyLv0hMO0pBvSJoepGjMq5ntS6NCYcboZJbuZsq2UAx70M6o\n\
RtN6oHxtdwvFR9stSNq6W3fp/uD28GMpTK1KISepV6BGS+cwcRG8Jh7eyoKCZhcn\n\
yAcOmcIoZGmEgXry6DJLE+lTPtIl8ycd5StkzOu29xr5GxwXk0Q/kUGAUJ4vcGGV\n\
U+/0YEAJZZzwMPoY++O/gKmkycQXx5D5yo7FaQHjt30PFMQzOEylzAvka8hbJtxN\n\
hI565udST4I/2SCL+g4tV6NO2+grfPA8z8PUU90ww0fkTyPEptViOtDxEYgrfsHz\n\
O8jvbjJHWt3x0ZF2QbJU7K09vJ33uTnwtQIDAQAB\n\
-----END RSA PUBLIC KEY-----\n";

TEST(AsymmetricKeyTest, TestEqualityOperator) {
  pep::AsymmetricKey privateKey = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKey = pep::AsymmetricKey(inputPublicKeyPEM);
  pep::AsymmetricKey privateKeyPKCS1 = pep::AsymmetricKey(inputPrivateKeyPEMPKCS1);
  pep::AsymmetricKey publicKeyPKCS1 = pep::AsymmetricKey(inputPublicKeyPEMPKCS1);

  // Test equality of the same keys
  EXPECT_TRUE(privateKey == privateKey);
  EXPECT_TRUE(publicKey == publicKey);
  EXPECT_TRUE(privateKeyPKCS1 == privateKeyPKCS1);
  EXPECT_TRUE(publicKeyPKCS1 == publicKeyPKCS1);

  // Test inequality of different keys
  EXPECT_FALSE(privateKey == privateKeyPKCS1);
  EXPECT_FALSE(publicKey == publicKeyPKCS1);

  // Test inequality of different key types
  EXPECT_FALSE(privateKey == publicKeyPKCS1);
  EXPECT_FALSE(publicKey == privateKeyPKCS1);

  // Test equality of keys with the same content
  pep::AsymmetricKey privateKeyDuplicate = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKeyDuplicate = pep::AsymmetricKey(inputPublicKeyPEM);
  EXPECT_TRUE(privateKey == privateKeyDuplicate);
  EXPECT_TRUE(publicKey == publicKeyDuplicate);
}

TEST(AsymmetricKeyTest, TestEncryption) {
  pep::AsymmetricKey privateKey = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKey = pep::AsymmetricKey(inputPublicKeyPEM);
  pep::AsymmetricKey privateKeyPKCS1 = pep::AsymmetricKey(inputPrivateKeyPEMPKCS1);
  pep::AsymmetricKey publicKeyPKCS1 = pep::AsymmetricKey(inputPublicKeyPEMPKCS1);

  std::string testData = "TestData";
  std::string encryptedData1 = publicKey.encrypt(testData);
  std::string encryptedData2 = publicKeyPKCS1.encrypt(testData);
  EXPECT_NE(encryptedData1, encryptedData2);

  EXPECT_NE(encryptedData1, "");

  std::string decryptedData1 = privateKey.decrypt(encryptedData1);
  EXPECT_EQ(testData, decryptedData1);

  std::string decryptedData2 = privateKeyPKCS1.decrypt(encryptedData2);
  EXPECT_EQ(testData, decryptedData2);
}

TEST(AsymmetricKeyTest, TestSignatures) {
  pep::AsymmetricKey privateKey = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKey = pep::AsymmetricKey(inputPublicKeyPEM);
  pep::AsymmetricKey privateKeyPKCS1 = pep::AsymmetricKey(inputPrivateKeyPEMPKCS1);
  pep::AsymmetricKey publicKeyPKCS1 = pep::AsymmetricKey(inputPublicKeyPEMPKCS1);

  // We need some serializable data
  std::string testData1 = pep::Sha256().digest("Some test");
  std::string testData2 = pep::Sha256().digest("Some other test");

  std::string signature = privateKey.signDigestSha256(testData1);
  EXPECT_NE("", signature);

  EXPECT_TRUE(publicKey.verifyDigestSha256(testData1, signature));

  EXPECT_FALSE(publicKey.verifyDigestSha256(testData2, signature));

  EXPECT_FALSE(publicKeyPKCS1.verifyDigestSha256(testData1, signature));

  // Provided digest
  std::vector<unsigned char> digestVector = {
    0x88, 0x51, 0xc7, 0xf9, 0xd9, 0xb4, 0x91, 0x41, 0xd8, 0x29, 0x2c, 0xa9, 0xd1, 0x82, 0xb2, 0xd4,
    0xd6, 0x5b, 0x8d, 0xe0, 0xab, 0x07, 0xaf, 0x8c, 0x50, 0xc4, 0x24, 0x79, 0x9a, 0xa5, 0x86, 0xd8
  };

  // Provided signature
  std::vector<unsigned char> signatureVector = {
    0x12, 0xcf, 0xb6, 0x04, 0xd7, 0xeb, 0x21, 0xed, 0xfe, 0x45, 0x04, 0x5c, 0x04, 0x20, 0xe9, 0x10,
    0x74, 0x03, 0x04, 0x8e, 0xfd, 0xf2, 0xd7, 0xb0, 0x94, 0xb0, 0x09, 0x2d, 0xfd, 0xd0, 0xdf, 0xd7,
    0xd2, 0x99, 0x3f, 0x4c, 0x47, 0xfd, 0x6b, 0xee, 0x49, 0xf2, 0x91, 0xdf, 0x1d, 0x50, 0x00, 0x66,
    0x64, 0x70, 0x31, 0x4b, 0xf9, 0x54, 0x6a, 0x05, 0x99, 0x91, 0x4d, 0xee, 0x13, 0x1e, 0x4a, 0x3b,
    0x87, 0xbf, 0xfe, 0x41, 0x41, 0x65, 0x07, 0x01, 0xbd, 0x83, 0x95, 0x76, 0xc9, 0xf9, 0x67, 0x4d,
    0x51, 0x14, 0x81, 0x1b, 0x12, 0x3d, 0x79, 0x1e, 0xc8, 0xb5, 0x15, 0xa0, 0xb4, 0x93, 0x02, 0x33,
    0xa4, 0xcb, 0x37, 0x8e, 0xdd, 0x98, 0x14, 0x46, 0xc2, 0x5d, 0xfa, 0xd3, 0xf4, 0x4f, 0x63, 0x51,
    0x65, 0x63, 0x47, 0xc3, 0x4b, 0xaa, 0xdc, 0x56, 0x3d, 0x01, 0xcc, 0x8a, 0xa8, 0x4c, 0x87, 0x4f,
    0xe2, 0x78, 0xbb, 0x62, 0x2c, 0x9b, 0x52, 0x2a, 0xc7, 0x65, 0x8c, 0x6c, 0xdc, 0x7c, 0x44, 0x1e,
    0xb9, 0x19, 0x68, 0xca, 0xb5, 0xa8, 0x4f, 0x26, 0x26, 0xbe, 0xb9, 0xff, 0x4e, 0x9a, 0x85, 0x41,
    0x14, 0x86, 0xbb, 0x96, 0x66, 0x02, 0x5c, 0x59, 0x5e, 0x4d, 0x1f, 0x44, 0x89, 0x80, 0xc0, 0x87,
    0xf5, 0xde, 0xf0, 0x1d, 0x5c, 0x05, 0x14, 0x50, 0x69, 0x3c, 0x9c, 0x31, 0x34, 0x13, 0x65, 0x72,
    0xac, 0x24, 0xd5, 0x3e, 0x33, 0xd5, 0x40, 0xb7, 0x1b, 0xf7, 0x96, 0x8f, 0xfb, 0x59, 0xf1, 0x72,
    0xf4, 0x77, 0x05, 0xf3, 0xa4, 0xad, 0x81, 0x3a, 0x49, 0xe6, 0xfb, 0x58, 0xb7, 0x71, 0x9a, 0x2c,
    0x37, 0x31, 0xa6, 0xc7, 0x6c, 0xea, 0xa2, 0x4a, 0x39, 0x56, 0x64, 0xcb, 0xee, 0x39, 0xac, 0xe0,
    0x30, 0x1c, 0x40, 0x6d, 0xed, 0x95, 0x71, 0x72, 0x5c, 0x32, 0x9e, 0x3a, 0xea, 0x90, 0x77, 0x51
  };

  // Convert vectors to strings
  std::string digest(digestVector.begin(), digestVector.end());
  std::string signature2(signatureVector.begin(), signatureVector.end());

  // Create AsymmetricKey object from public key
  pep::AsymmetricKey publicKeySignatureTest = pep::AsymmetricKey(inputPublicKeyPEMSignatureTest);

  // Verify the signature
  EXPECT_TRUE(publicKeySignatureTest.verifyDigestSha256(digest, signature2)) << "Signature verification failed";
}

TEST(AsymmetricKeyTest, TestPEM) {
  pep::AsymmetricKey privateKey = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKey = pep::AsymmetricKey(inputPublicKeyPEM);

  std::string privateKeyPEM = privateKey.toPem();
  EXPECT_NE(privateKeyPEM, "") << "Output private key PEM is empty";
  EXPECT_EQ(privateKeyPEM, inputPrivateKeyPEM) << "Input PEM is not equal to output PEM";

  std::string publicKeyPEM = publicKey.toPem();
  EXPECT_NE(publicKeyPEM, "") << "Output public key PEM is empty";
  EXPECT_EQ(publicKeyPEM, inputPublicKeyPEM) << "Input PEM is not equal to output PEM";
}

TEST(AsymmetricKeyTest, TestDER) {
  pep::AsymmetricKey privateKey = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKey = pep::AsymmetricKey(inputPublicKeyPEM);

  std::string privateKeyDER = privateKey.toDer();
  EXPECT_NE(privateKeyDER, "") << "Output private key DER is empty";
  EXPECT_EQ(privateKeyDER, inputPrivateKeyDER) << "Input DER is not equal to output DER";

  std::string publicKeyDER = publicKey.toDer();
  EXPECT_NE(publicKeyDER, "") << "Output public key DER is empty";
  EXPECT_EQ(publicKeyDER, inputPublicKeyDER) << "Input DER is not equal to output DER";
}

TEST(AsymmetricKeyTest, TestIsPrivateKeyFor) {
  pep::AsymmetricKey privateKey = pep::AsymmetricKey(inputPrivateKeyPEM);
  pep::AsymmetricKey publicKey = pep::AsymmetricKey(inputPublicKeyPEM);

  EXPECT_TRUE(privateKey.isPrivateKeyFor(publicKey));

  pep::AsymmetricKey privateKeyPKCS1 = pep::AsymmetricKey(inputPrivateKeyPEMPKCS1);
  pep::AsymmetricKey publicKeyPKCS1 = pep::AsymmetricKey(inputPublicKeyPEMPKCS1);

  EXPECT_TRUE(privateKeyPKCS1.isPrivateKeyFor(publicKeyPKCS1)) << "PKCS1 keys are not recognized as a pair";
  EXPECT_FALSE(privateKey.isPrivateKeyFor(publicKeyPKCS1)) << "Different key types are recognized as a pair";
  EXPECT_FALSE(privateKeyPKCS1.isPrivateKeyFor(publicKey)) << "Different key types are recognized as a pair";
}

TEST(AsymmetricKeyPairTest, Generation) {
  pep::AsymmetricKeyPair keyPair = pep::AsymmetricKeyPair::GenerateKeyPair();
}

TEST(AsymmetricKeyPairTest, EncryptionDecryption) {
  pep::AsymmetricKeyPair keyPair = pep::AsymmetricKeyPair::GenerateKeyPair();

  pep::AsymmetricKey privateKey = keyPair.getPrivateKey();
  pep::AsymmetricKey publicKey = keyPair.getPublicKey();

  std::string testData = "TestData";
  std::string encryptedData = publicKey.encrypt(testData);
  EXPECT_NE(encryptedData, "") << "Encrypted data is empty";

  std::string decryptedData = privateKey.decrypt(encryptedData);
  EXPECT_EQ(testData, decryptedData) << "Decrypted data is not equal to original data";
}

TEST(AsymmetricKeyPairTest, TestIsPrivateKeyFor) {
  pep::AsymmetricKeyPair keyPair = pep::AsymmetricKeyPair::GenerateKeyPair();
  pep::AsymmetricKey privateKey = keyPair.getPrivateKey();
  pep::AsymmetricKey publicKey = keyPair.getPublicKey();

  EXPECT_TRUE(privateKey.isPrivateKeyFor(publicKey)) << "Generated key pair is not recognized as a pair";
}

}
